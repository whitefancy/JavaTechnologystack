package JavaBasics;

public class finalStaticUsage {
    //final关键字用法
    //1.修饰数据是不可变的
    //在编写程序时，我们经常需要说明一个数据是不可变的，我们成为常量。在java中，用final关键字修饰的变量，只能进行一次赋值操作，并且在生存期内不可以改变它的值。更重要的是，final会告诉编译器，这个数据是不会修改的，那么编译器就可能会在编译时期就对该数据进行替换甚至执行计算，这样可以对我们的程序起到一点优化。不过在针对基本类型和引用类型时，final关键字的效果存在细微差别。
    //我们先来看一下main方法中的几个final修饰的数据，在给value1赋初始值之后，我们无法再对value1的值进行修改，final关键字起到了常量的作用。从value2我们可以看到，final修饰的变量可以不在声明时赋值，即可以先声明，后赋值。value3时一个引用变量，这里我们可以看到final修饰引用变量时，只是限定了引用变量的引用不可改变，即不能将value3再次引用另一个Value对象，但是引用的对象的值是可以改变的。
    //上图中，final修饰的值用粗线条的边框表示它的值是不可改变的，我们知道引用变量的值实际上是它所引用的对象的地址，也就是说该地址的值是不可改变的，从而说明了为什么引用变量不可以改变引用对象。而实际引用的对象实际上是不受final关键字的影响的，所以它的值是可以改变的。
    //另一方面，我们看到了用final修饰成员变量时的细微差别，因为final修饰的数据的值是不可改变的，所以我们必须确保在使用前就已经对成员变量赋值了。因此对于final修饰的成员变量，我们有且只有两个地方可以给它赋值，一个是声明该成员时赋值，另一个是在构造方法中赋值，在这两个地方我们必须给它们赋初始值。
    //最后我们需要注意的一点是，同时使用static和final修饰的成员在内存中只占据一段不能改变的存储空间。
    //2.修饰方法 整个方法中不能改变参数的值
    //前面我们可以看到，如果变量是我们自己创建的，那么使用final修饰表示我们只会给它赋值一次且不会改变变量的值。那么如果变量是作为参数传入的，我们怎么保证它的值不会改变呢？这就用到了final的第二种用法，即在我们编写方法时，可以在参数前面添加final关键字，它表示在整个方法中，我们不会（实际上是不能）改变参数的值：
    //3.修饰方法 该方法不能被覆盖
    //第三种方式，即用final关键字修饰方法，它表示该方法不能被覆盖。这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。
    //4.修饰类 无法被继承的
    //了解了final关键字的其他用法，我们很容易可以想到使用final关键字修饰类的作用，那就是用final修饰的类是无法被继承的。
    //上面我们讲解了final的四种用法，然而，对于第三种和第四种用法，我们却甚少使用。这不是没有道理的，从final的设计来讲，这两种用法甚至可以说是鸡肋，因为对于开发人员来讲，如果我们写的类被继承的越多，就说明我们写的类越有价值，越成功。即使是从设计的角度来讲，也没有必要将一个类设计为不可继承的。Java标准库就是一个很好的反例，特别是Java 1.0/1.1中Vector类被如此广泛的运用，如果所有的方法均未被指定为final的话，它可能会更加有用。如此有用的类，我们很容易想到去继承和重写他们，然而，由于final的作用，导致我们对Vector类的扩展受到了一些阻碍，导致了Vector并没有完全发挥它应有的全部价值。见过的用法 Util，Menu，Token，serialize.Method
    //使用final关键字修饰一个变量时，是引用的对象不能变
    //使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。
    //如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。
    //final变量用于同步机制
    //还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时。考虑以下声明：
    //final Map<String, Double〉accounts = new HashKap<>0；
    //其他线程会在构造函数完成构造之后才看到这个 accounts 变量。
    //对这个映射表的操作并不是线程安全的。如果多个线程在读写这个映射表，仍然需要进行同步。
    //static 关键字
    //static的四种用法
    //1.修饰成员变量 类成员或者静态成员
    //在我们平时的使用当中，static最常用的功能就是修饰类的属性和方法，让他们成为类的成员属性和方法，我们通常将用static修饰的成员称为类成员或者静态成员，这句话挺起来都点奇怪，其实这是相对于对象的属性和方法来说的。请看下面的例子：（未避免程序太过臃肿，暂时不管访问控制）
    //实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。
    //虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。
    //因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。
    //推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。
    //interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型。
    //2.修饰成员方法 避免了先要new出对象资源消耗
    //static的另一个作用，就是修饰成员方法。 相比于修饰成员属性，修饰成员方法对于数据的存储上面并没有多大的变化，因为我们从上面可以看出，方法本来就是存放在类的定义当中的。static修饰成员方法最大的作用，就是可以使用"类名.方法名"的方式操作方法，避免了先要new出对象的繁琐和资源消耗，我们可能会经常在帮助类中看到它的使用。
    //用static修饰的方法称为静态方法。
    //调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如：
    //因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。
    //通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。
    //通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。
    //静态方法经常用于工具类。例如：
    //Arrays.sort()
    //Math.random()
    //静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。
    //静态方法常用于工具类和辅助方法。
    //父类不能调用子类的静态方法。
    //3.静态块 会按照他们的先后位置进行初始化 初始化可以更早的进行
    //在说明static关键字的第三个用法时，我们有必要重新梳理一下一个对象的初始化过程。以下面的代码为例：
    //上面的例子中，Person类中组合了四个Book成员变量，两个是普通成员，两个是static修饰的类成员。我们可以看到，当我们new一个Person对象时，static修饰的成员变量首先被初始化，随后是普通成员，最后调用Person类的构造方法完成初始化。也就是说，在创建对象时，static修饰的成员会首先被初始化，而且我们还可以看到，如果有多个static修饰的成员，那么会按照他们的先后位置进行初始化。
    //实际上，static修饰的成员的初始化可以更早的进行，
    //在上面的例子中我们可以发现两个有意思的地方，第一个是当我们没有创建对象，而是通过类去调用类方法时，尽管该方法没有使用到任何的类成员，类成员还是在方法调用之前就初始化了，这说明，当我们第一次去使用一个类时，就会触发该类的成员初始化。第二个是当我们使用了类方法，完成类的成员的初始化后，再new该类的对象时，static修饰的类成员没有再次初始化，这说明，static修饰的类成员，在程序运行过程中，只需要初始化一次即可，不会进行多次的初始化。
    //4.静态导包 不与当前类的方法名冲突的情况下
    //相比于上面的三种用途，第四种用途可能了解的人就比较少了，但是实际上它很简单，而且在调用类方法时会更方便。以上面的“PrintHelper”的例子为例，做一下稍微的变化，即可使用静态导包带给我们的方便：
    //import static com.dotgua.study.PrintHelper.*;
    //上面的代码来自于两个java文件，其中的PrintHelper很简单，包含了一个用于打印的static方法。而在App.java文件中，我们首先将PrintHelper类导入，这里在导入时，我们使用了static关键字，而且在引入类的最后还加上了“.*”，它的作用就是将PrintHelper类中的所有类方法直接导入。不同于非static导入，采用static导入包后，在不与当前类的方法名冲突的情况下，无需使用“类名.方法名”的方法去调用类方法了，直接可以采用"方法名"去调用类方法，就好像是该类自己的方法一样使用即可。
    //Static隐藏（非继承）
    //java中静态属性和静态方法可以被继承，但是没有被重写(overwrite)而是被隐藏。
    //1.静态变量与静态方法说继承并不确切，静态方法与变量是属于类的方法与变量。而子类也属于超类，比如说Manage extends Employee，则Manage也是一个Employee，所以子类能够调用属于超类的静态变量和方法。注意，子类调用的其实就是超类的静态方法和变量，而不是继承自超类的静态方法与变量。但是如果子类中有同名的静态方法与变量，这时候调用的就是子类本身的，因为子类的静态变量与静态方法会隐藏父类的静态方法和变量。
    //2.如果子类中没有定义同名的变量和方法，那么调用 "子类名.静态方法/变量"调用的是父类的方法及变量
    //3,.如果子类中只定义了同名静态变量，而没有定义与父类同名静态方法，则调用”子类名.静态方法"时，调 用的是父类的静态方法，静态方法中的静态变量也是父类的 (如程序中注[1])
    //4.如果子类中既定义了与父类同名的静态变量，也定义了与父类同名的静态方法，这时候调用”子类名.静态方法"时，完全与父类无关，里面的静态变量也是子类的(如程序中注[2])
    //静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成，不需要继承机制就可以调用。如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为"隐藏"。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或父类名.变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在"隐藏"的这种情况。
    //不能使用super
    //多态之所以能够实现依赖于继承、接口和重写、重载（继承和重写最为关键）。有了继承和重写就可以实现父类的引用指向不同子类的对象。重写的功能是："重写"后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。
    //静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。
    //非静态方法可以被继承和重写，因此可以实现多态。
    //重写和隐藏的区别是："重写"后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。
    //  静态域、静态方法和非静态域都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向子类的对象时的动态绑定。非静态方法可以被继承和重写，因此可以实现多态。
    //静态变量和实例变量的区别？
    //在语法定义上的区别：static关键字
    //静态变量前要加static关键字，而实例变量前则不加。
    //在程序运行时的区别：创建了实例对象，其中的实例变量才会被分配空间
    //实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间。
    //静态变量不属于某个实例对象，而是属于类，只要程序加载了类的字节码，静态变量就会被分配空间，总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。
    //不可以从一个static方法内部发出对非static方法的调用
    //不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，
    //而static方法调用时不需要创建对象，可以直接调用。
    //重写
    //在继承过程中，子类中从父类继承来的方法无法满足自己的需求时，可以在子类中对父类方法进行完善，这个完善过程叫做方法重写(override)，方法的重写相当于在子类中覆盖父类中的方法。
    //1 在继承过程中，方法名、参数列表、返回值类型必须和父类相同
    //2 访问修饰符不能比父类严格
    //java 1.7 返回值可以和父类兼容就可以，必须是引用类型
    //super返回Object，child返回String是合法的。返回int是不合法的。
    //只要在子类中重写了父类的方法，通过子类对象调用该方法一定是子类重写的方法。
}
