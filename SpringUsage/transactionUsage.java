package SpringUsage;

public class transactionUsage {
    //Spring事务的实现方式和实现原理：
    //Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。
    //（1）Spring事务的种类：
    //spring支持编程式事务管理和声明式事务管理两种方式：
    //①编程式事务管理使用TransactionTemplate。
    //②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。
    //声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。
    //声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。
    //（2）spring的事务传播行为：
    //spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。
    //① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。
    //② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。
    //③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
    //④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。
    //⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
    //⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。
    //⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。
    //（3）Spring中的隔离级别：
    //① ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。
    //② ISOLATION_READ_UNCOMMITTED：读未提交，允许另外一个事务可以看到这个事务未提交的数据。
    //③ ISOLATION_READ_COMMITTED：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。
    //④ ISOLATION_REPEATABLE_READ：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。
    //⑤ ISOLATION_SERIALIZABLE：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。
    //使用Spring管理事务
    //理解事务管理
    //保护数据的完整性
    //Spring的事务抽象模型
    //事务划分
    //数据操作完成后提交事务，或发生错误时回滚事务
    //本地事务
    //使用单一数据库
    //全局事务
    //分布式事务管理
    //2PC提交
    //从代码中抽象出不同的事务划分步骤，并以编程或声明的方式提供API划分事务
    //Spring支持的事务管理类型
    //Spring支持两种类型的事务管理：
    //编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。
    //声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。
    //Spring支持如下两种方式的事务管理： 编码式事务管理：sping对编码式事务的支持与EJB有很大区别，不像EJB与java事务API耦合在一起．spring通过回调机制将实际的事务实现从事务性代码中抽象出来．你能够精确控制事务的边界，它们的开始和结束完全取决于你． 声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。通过传播行为，隔离级别，回滚规则，事务超时，只读提示来定义．
    //Spring框架的事务管理有哪些优点？
    //它为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。
    //它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如
    //它支持声明式事务管理。
    //它和Spring各种数据访问抽象层很好得集成。
    //它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。 它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA). 它支持声明式事务管理。 它可以和Spring 的多种数据访问技术很好的融合。
    //ACID
    //原子性(Atomic):一个操作要么成功，要么全部不执行.
    //一致性(Consistent): 一旦事务完成，系统必须确保它所建模业务处于一致的状态
    //隔离性(Isolated): 事务允许多个用户对相同的数据进行操作，每个用户用户的操作相互隔离互补影响．
    //持久性(Durable): 一旦事务完成，事务的结果应该持久化．
    //spring事务定义的传播规则
    //PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。
    //PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。
    //PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。
    //PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。
    //PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
    //PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。
    //PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。
    //spring事务支持的隔离级别
    //并发会导致以下问题：
    //藏读：发生在一个事务读取了另一个事务改写但尚未提交的数据．
    //不可重复读：在一个事务执行相同的查询两次或两次以上，每次得到的数据不同．
    //幻读：与不可重复读类似，发生在一个事务读取多行数据，接着另一个并发事务插入一些数据，随后查询中，第一个事务发现多了一些原本不存在的数据．
    //spring 事务上提供以下的隔离级别:
    //ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别
    //ISOLATION_READ_UNCOMMITTED　: 允许读取未提交的数据变更，可能会导致脏读，幻读或不可重复读
    //ISOLATION_READ_COMMITTD : 允许读取为提交数据,可以阻止脏读，当时幻读或不可重复读仍可能发生
    //ISOLATION_REPEATABLE_READ: 对统一字段多次读取结果是一致的，除非数据是被本事务自己修改．可以阻止脏读，不可重复读，但幻读可能发生
    //ISOLATION_SERIALIZABLE :　完全服从ACID
    //你更倾向用那种事务管理类型？
    //大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。
    //好处
    //系统与底层数据访问技术完全隔离，方便切换和同时使用多种技术
    //使用transactionManager的Bean定义的修改来更改数据访问策略
    //重新配置bean就可以切换本地事务和全局事务
    //使用Spring进行声明式事务管理
    //Spring使用面向方面编程来完成事务管理
    //声明式事务管理，要求制定Bean中哪些方法将被事务化
    //方法体中不需要编写任何事务划分代码
    //启用
    //注解
    //@EnableTransactionManagement 启用事务
    //该注解激活了基于注解的声明式事务管理，扫描被管理的Bean类们，一边找到Transactional注解
    //@Transactional 事务化
    //在类上加关键字，类中所有的公共方法都被事务化
    //参数
    //propagation 事务范围
    //值
    //REQUIRES_NEW
    //不管是否存在活动事务，开启新事务
    //NESTED 在第二个方法调用的位置创建一个保存点
    //isolation 隔离级别
    //timeout 事务超时时间，可以传递给底层数据库系统
    //readonly 提示底层事务是只读的
    //rollbackFor noRollbackFor
    //发生异常时，指定要调用的动作
    //添加一个DAO数据访问层，将数据访问操作封装到该层
    //调用事务服务方法时，如果事务不存在，则开始事务，将事务资源（Connection对象）存储在ThreadLocal数据结构中，访问该资源
    //事务传播规则
    //事务范围
    //何时触发
    //是否暂停
    //是否失败
    //使用Spring进行编程式事务管理
    //在事务之前或之后执行自定义逻辑
}
