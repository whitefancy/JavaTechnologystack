package javacore;

/**
 * 监视器
 * 不需要程序员知道如何加锁，保证多线程的安全性
 * 特性
 * 监视器只包含私有域
 * 类对象有一个锁
 * 使用该锁对监视器类的所有方法加锁
 */
public class MonitorTest {
    /*
    Volatile域
    现代处理器 多处理器能暂存在寄存器或本地内存 缓冲区的值 不同处理器的线程可能在同一个内存位置取到不同值
    现代编译器 可以改变 指令执行的顺序使 吞吐量最大化  编译器在 改变顺序时 假定内存的值只会在有显式的修改指令时才会改变
    但是，内存的值可以被另一个线程改变

    使用锁之后，值变化，编译器会被要求在必要的时候刷新本地缓存 来保持锁的效应 并且不能不正当地重新排列指令

    同步格言：如果写入后，可能被另一个线程读取，，或者读之前，可能被另一个线程写入， 就必须使用同步。

    volatile关键字 为 实例域的同步访问 提供免锁机制，声明成volatile后编译器和虚拟机就知道该域可能被并发更新
    但是 volatile不能提供 原子性， 即使是 done=!done; 这样的翻转，都不能保证不被中断
     */

    /*
    final变量
    要么读到null，要么读到同一个值，但是写入的时候，是不安全的
     */
    /*
    如果对共享变量，只做赋值的操作，可以声明为volatile

    concurrent.atomic包 有很多类，保证了操作的原子性 比如 AtomicInteger， 方法保证了不被中断
    其CompareAndSet方法，会映射到一个 处理器操作， 比使用锁 速度更快

    上述atomic开头的，使用的是乐观锁， 即 更新需要太多次重试
    Java8提供了Long开头的类，只有当所有工作都完成后，才会得到总和的值，性能显著提升。当存在大量竞争，需要使用这个
     */

    /*
    死锁  Java不能避免或打破死锁现象
    比如账户互转，而且金额都大于余额 一段时间后，所有对线程都被阻塞，程序将挂起，等待。
     */
    /*
    线程局部变量
    
     */
}
